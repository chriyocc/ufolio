// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/unsupportedError.js
var UnsupportedError = class extends Error {
  constructor(message = "Unsupported") {
    super(message);
  }
};
function createUnsupportedError(message) {
  return new UnsupportedError(message);
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/qualifierToJson.js
function qualifierToJson() {
  return this._qualifierModel || { error: createUnsupportedError(`unsupported qualifier ${this.constructor.name}`) };
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/QualifierModel.js
var QualifierModel = class {
  constructor() {
    this._qualifierModel = {};
  }
  toJson() {
    return qualifierToJson.apply(this);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/BaseSource.js
var BaseSource = class extends QualifierModel {
  /**
   * @description Utility function to encode an asset publicID in an overlay
   * @protected
   * @example
   * encodeAssetPublicID('foo/bar'); // -> foo:bar
   */
  encodeAssetPublicID(publicID) {
    return publicID.replace(/\//g, ":");
  }
  /**
   * @description
   * Apply a transformation on the image source of the layer
   * @param {SDK.ImageTransformation} t An image transformation to apply to the layer
   * @returns {this}
   */
  transformation(t) {
    this._qualifierModel.transformation = t.toJson();
    this._transformation = t;
    return this;
  }
  /**
   * @description Returns the Transformation of the source
   * @return {SDK.Transformation}
   */
  getTransformation() {
    return this._transformation;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/VideoSource.js
var VideoSource = class extends BaseSource {
  constructor(publicID) {
    super();
    this._publicID = publicID;
    this._qualifierModel = {
      publicId: publicID,
      sourceType: "video"
    };
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const encodedPublicID = this.encodeAssetPublicID(this._publicID);
    return `${layerType}_video:${encodedPublicID}`;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { publicId, transformation } = qualifierModel;
    const result = new this(publicId);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/ImageSource.js
var ImageSource = class extends BaseSource {
  constructor(publicID) {
    super();
    this._publicID = publicID;
    this._qualifierModel = {
      publicId: publicID,
      sourceType: "image"
    };
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const encodedPublicID = this.encodeAssetPublicID(this._publicID);
    if (this._format) {
      return `${layerType}_${encodedPublicID}.${this._format.toString()}`;
    } else {
      return `${layerType}_${encodedPublicID}`;
    }
  }
  /**
   * @description
   * Apply a format for the image source of the layer
   * @param {FormatQualifier} format A to apply to the layered image, see more {@link Qualifiers.Format|here}
   * @returns {this}
   */
  format(format) {
    this._format = format;
    return this;
  }
  toJson() {
    const result = super.toJson();
    if (result.publicId && this._format) {
      result.publicId = `${result.publicId}.${this._format.toString()}`;
    }
    return result;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { publicId, transformation } = qualifierModel;
    const result = new this(publicId);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/fontWeight.js
function thin() {
  return "thin";
}
function light() {
  return "light";
}
function normal() {
  return "normal";
}
function bold() {
  return "bold";
}
var FontWeight = { bold, light, normal, thin };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/fontStyle.js
function normal2() {
  return "normal";
}
function italic() {
  return "italic";
}
var FontStyle = { normal: normal2, italic };

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/textDecoration.js
function normal3() {
  return "";
}
function underline() {
  return "underline";
}
function strikethrough() {
  return "strikethrough";
}
var TextDecoration = { normal: normal3, underline, strikethrough };

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/serializeCloudinaryCharacters.js
function serializeCloudinaryCharacters(str = "") {
  return str.replace(/,/g, "%2C").replace(/\//g, "%2F");
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/textStroke.js
function solid(width, color) {
  return `bo_${width}px_solid_${color}`;
}
var Stroke = { solid };

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/IStrokeModel.js
function isISolidStrokeModel(obj) {
  return typeof obj === "object" && obj.width != null && obj.color != null;
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/textStyle.js
var TextStyle = class extends QualifierModel {
  /**
   * @param {string} fontFamily The font family
   * @param {number | string} fontSize The font size
   */
  constructor(fontFamily, fontSize) {
    super();
    if (!fontFamily || !fontSize) {
      throw `You must provide a fontFamily and fontSize to a TextStyle`;
    }
    this._qualifierModel.fontFamily = fontFamily;
    this._qualifierModel.fontSize = fontSize;
  }
  /**
   * @param {number} spacing The spacing between multiple lines in pixels.
   */
  lineSpacing(spacing) {
    this._qualifierModel.lineSpacing = spacing;
    return this;
  }
  /**
   * @param spacing The spacing between the letters, in pixels.
   */
  letterSpacing(spacing) {
    this._qualifierModel.letterSpacing = spacing;
    return this;
  }
  /**
   * The antialias setting to apply to the text. When this parameter is not specified, the default antialiasing for the subsystem and target device are applied.
   * @param {FontAntialiasType|string} antiAlias
   */
  fontAntialias(antiAlias) {
    this._qualifierModel.fontAntialias = antiAlias;
    return this;
  }
  /**
   * The name of any universally available font or a custom font, specified as the public ID of a raw, authenticated font in your account.
   * For details on custom fonts, see {@link https://cloudinary.com/documentation/layers#custom_fonts|Using custom fonts for text overlays}.
   * @param {string} fontFamilyName
   */
  fontFamily(fontFamilyName) {
    this._qualifierModel.fontFamily = fontFamilyName;
    return this;
  }
  /**
   * @param {number} fontSize The font size
   */
  fontSize(fontSize) {
    this._qualifierModel.fontSize = fontSize;
    return this;
  }
  /**
   * @param {FontWeightType|string} fontWeight The font weight
   */
  fontWeight(fontWeight) {
    this._qualifierModel.fontWeight = fontWeight;
    return this;
  }
  /**
   *
   * @param {string} fontStyle The font style.
   */
  fontStyle(fontStyle) {
    this._qualifierModel.fontStyle = fontStyle;
    return this;
  }
  /**
   * @param {string} fontHinting The outline hinting style to apply to the text. When this parameter is not specified, the default hint style for the font and target device are applied.
   */
  fontHinting(fontHinting) {
    this._qualifierModel.fontHinting = fontHinting;
    return this;
  }
  /**
   *
   * @param {TextDecorationType|string} textDecoration The font decoration type.
   */
  textDecoration(textDecoration) {
    this._qualifierModel.textDecoration = textDecoration;
    return this;
  }
  /**
   * @param {TextAlignmentType|string} textAlignment The text alignment
   */
  textAlignment(textAlignment) {
    this._qualifierModel.textAlignment = textAlignment;
    return this;
  }
  /**
   * @description Whether to include an outline stroke. Set the color and weight of the stroke
   */
  stroke(textStroke) {
    if (textStroke) {
      const strokeStyle = textStroke.split("_");
      this._qualifierModel.stroke = {
        width: +strokeStyle[1].replace("px", ""),
        color: strokeStyle[strokeStyle.length - 1]
      };
    } else {
      this._qualifierModel.stroke = true;
    }
    return this;
  }
  toString() {
    const { stroke } = this._qualifierModel;
    let strokeStr = "";
    if (stroke) {
      strokeStr = isISolidStrokeModel(stroke) ? `stroke_${solid(stroke.width, stroke.color)}` : "stroke";
    }
    return [
      `${serializeCloudinaryCharacters(this._qualifierModel.fontFamily)}_${this._qualifierModel.fontSize}`,
      this._qualifierModel.fontWeight !== normal() && this._qualifierModel.fontWeight,
      this._qualifierModel.fontStyle !== normal2() && this._qualifierModel.fontStyle,
      this._qualifierModel.textDecoration !== normal3() && this._qualifierModel.textDecoration,
      this._qualifierModel.textAlignment,
      strokeStr,
      this._qualifierModel.letterSpacing && `letter_spacing_${this._qualifierModel.letterSpacing}`,
      this._qualifierModel.lineSpacing && `line_spacing_${this._qualifierModel.lineSpacing}`,
      this._qualifierModel.fontAntialias && `antialias_${this._qualifierModel.fontAntialias}`,
      this._qualifierModel.fontHinting && `hinting_${this._qualifierModel.fontHinting}`
    ].filter((a) => a).join("_");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/qualifier/QualifierValue.js
var QualifierValue = class {
  /**
   *
   * @param {QualifierValue | QualifierValue[] | any[] | string | number}qualifierValue
   */
  constructor(qualifierValue) {
    this.values = [];
    this.delimiter = ":";
    if (this.hasValue(qualifierValue)) {
      this.addValue(qualifierValue);
    }
  }
  /**
   * @description Joins the provided values with the provided delimiter
   */
  toString() {
    return this.values.join(this.delimiter);
  }
  /**
   * @description Checks if the provided argument has a value
   * @param {any} v
   * @private
   * @return {boolean}
   */
  hasValue(v) {
    return typeof v !== "undefined" && v !== null && v !== "";
  }
  /**
   * @desc Adds a value for the this qualifier instance
   * @param {any} value
   * @return {this}
   */
  addValue(value) {
    if (Array.isArray(value)) {
      this.values = this.values.concat(value);
    } else {
      this.values.push(value);
    }
    this.values = this.values.filter((v) => this.hasValue(v));
    return this;
  }
  /**
   * @description Sets the delimiter for this instance
   * @param delimiter
   */
  setDelimiter(delimiter) {
    this.delimiter = delimiter;
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/qualifier/Qualifier.js
var Qualifier = class extends QualifierModel {
  constructor(key, qualifierValue) {
    super();
    this.delimiter = "_";
    this.key = key;
    if (qualifierValue instanceof QualifierValue) {
      this.qualifierValue = qualifierValue;
    } else {
      this.qualifierValue = new QualifierValue();
      this.qualifierValue.addValue(qualifierValue);
    }
  }
  toString() {
    const { key, delimiter, qualifierValue } = this;
    return `${key}${delimiter}${qualifierValue.toString()}`;
  }
  addValue(value) {
    this.qualifierValue.addValue(value);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/flag/FlagQualifier.js
var FlagQualifier = class extends Qualifier {
  constructor(flagType, flagValue) {
    let qualifierValue;
    if (flagValue) {
      qualifierValue = new QualifierValue([flagType, `${flagValue}`]).setDelimiter(":");
    } else {
      qualifierValue = flagType;
    }
    super("fl", qualifierValue);
    this.flagValue = flagValue;
  }
  toString() {
    return super.toString().replace(/\./g, "%2E");
  }
  getFlagValue() {
    return this.flagValue;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/dataStructureUtils.js
function mapToSortedArray(map, flags) {
  const array = Array.from(map.entries());
  flags.forEach((flag) => {
    array.push(["fl", flag]);
  });
  return array.sort().map((v) => v[1]);
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/actionToJson.js
function actionToJson() {
  var _a, _b, _c;
  const actionModelIsNotEmpty = this._actionModel && Object.keys(this._actionModel).length;
  const sourceTransformationError = (_c = (_b = (_a = this._actionModel) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.transformation) === null || _c === void 0 ? void 0 : _c.error;
  if (sourceTransformationError && sourceTransformationError instanceof Error) {
    return { error: sourceTransformationError };
  }
  if (actionModelIsNotEmpty) {
    return this._actionModel;
  }
  return { error: createUnsupportedError(`unsupported action ${this.constructor.name}`) };
}

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/ActionModel.js
var ActionModel = class {
  constructor() {
    this._actionModel = {};
  }
  toJson() {
    return actionToJson.apply(this);
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/Action.js
var Action = class extends ActionModel {
  constructor() {
    super(...arguments);
    this.qualifiers = /* @__PURE__ */ new Map();
    this.flags = [];
    this.delimiter = ",";
    this.actionTag = "";
  }
  prepareQualifiers() {
  }
  /**
   * @description Returns the custom name tag that was given to this action
   * @return {string}
   */
  getActionTag() {
    return this.actionTag;
  }
  /**
   * @description Sets the custom name tag for this action
   * @return {this}
   */
  setActionTag(tag) {
    this.actionTag = tag;
    return this;
  }
  /**
   * @description Calls toString() on all child qualifiers (implicitly by using .join()).
   * @return {string}
   */
  toString() {
    this.prepareQualifiers();
    return mapToSortedArray(this.qualifiers, this.flags).join(this.delimiter);
  }
  /**
   * @description Adds the parameter to the action.
   * @param {SDK.Qualifier} qualifier
   * @return {this}
   */
  addQualifier(qualifier) {
    if (typeof qualifier === "string") {
      const [key, value] = qualifier.toLowerCase().split("_");
      if (key === "fl") {
        this.flags.push(new FlagQualifier(value));
      } else {
        this.qualifiers.set(key, new Qualifier(key, value));
      }
    } else {
      this.qualifiers.set(qualifier.key, qualifier);
    }
    return this;
  }
  /**
   * @description Adds a flag to the current action.
   * @param {Qualifiers.Flag} flag
   * @return {this}
   */
  addFlag(flag) {
    if (typeof flag === "string") {
      this.flags.push(new FlagQualifier(flag));
    } else {
      if (flag instanceof FlagQualifier) {
        this.flags.push(flag);
      }
    }
    return this;
  }
  addValueToQualifier(qualifierKey, qualifierValue) {
    this.qualifiers.get(qualifierKey).addValue(qualifierValue);
    return this;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/prepareColor.js
function prepareColor(color) {
  if (color) {
    return color.match(/^#/) ? `rgb:${color.substr(1)}` : color;
  } else {
    return color;
  }
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/BaseTextSource.js
var BaseTextSource = class extends BaseSource {
  constructor(text2, textStyle) {
    super();
    this.type = "text";
    this.text = text2;
    this._textStyle = textStyle;
    this._qualifierModel.sourceType = "text";
    this._qualifierModel.text = text2;
    if (textStyle instanceof TextStyle) {
      this._qualifierModel.textStyle = textStyle.toJson();
    }
  }
  encodeText(text2) {
    return serializeCloudinaryCharacters(text2);
  }
  textColor(color) {
    this._textColor = color;
    this._qualifierModel.textColor = color;
    return this;
  }
  backgroundColor(bgColor) {
    this._backgroundColor = bgColor;
    this._qualifierModel.backgroundColor = bgColor;
    return this;
  }
  textFit(textFit) {
    this._textFit = textFit;
    return this;
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const layerParam = [
      this.type,
      this._textStyle && this._textStyle.toString(),
      this.encodeText(this.text)
    ].filter((a) => a).join(":");
    const tmpAction = new Action();
    tmpAction.addQualifier(new Qualifier(layerType, layerParam));
    this._textColor && tmpAction.addQualifier(new Qualifier("co", prepareColor(this._textColor)));
    this._backgroundColor && tmpAction.addQualifier(new Qualifier("b", prepareColor(this._backgroundColor)));
    this._textFit && tmpAction.addQualifier(this._textFit);
    return tmpAction.toString();
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/SubtitlesSource.js
var SubtitlesSource = class extends BaseTextSource {
  constructor(fileName) {
    super(fileName);
    this.type = "subtitles";
    this._qualifierModel = {
      sourceType: "subtitles",
      publicId: fileName
    };
  }
  /**
   * @description Set the textStyle for the subtitles layer
   * @param {TextStyle} textStyle
   */
  textStyle(textStyle) {
    this._textStyle = textStyle;
    this._qualifierModel.textStyle = textStyle.toJson();
    return this;
  }
  /**
   *
   * @description Used within getOpenSourceString of TextSource, this function overwrites the default encoding behaviour
   * Subtitle file names require a different encoding than texts
   * @param text
   * @example
   * encodeText('foo/bar'); // -> foo:bar
   */
  encodeText(text2) {
    return text2.replace(/\//g, ":");
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/format/FormatQualifier.js
var FormatQualifier = class extends QualifierValue {
  constructor(val) {
    super(val);
    this.val = val;
  }
  getValue() {
    return this.val;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/utils/base64Encode.js
function base64Encode(input) {
  let encodedResult = "";
  if (typeof window !== "undefined") {
    encodedResult = btoa(encodeURI(decodeURI(input)));
  } else {
    encodedResult = global.Buffer.from(input).toString("base64");
  }
  return encodedResult.replace(/\+/g, "-").replace(/\//g, "_");
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/FetchSource.js
var FetchSource = class extends BaseSource {
  constructor(remoteURL) {
    super();
    this._qualifierModel = {
      sourceType: "fetch",
      url: remoteURL
    };
    this._remoteURL = remoteURL;
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    if (this._format) {
      return `${layerType}_fetch:${base64Encode(this._remoteURL)}.${this._format.toString()}`;
    } else {
      return `${layerType}_fetch:${base64Encode(this._remoteURL)}`;
    }
  }
  /**
   * @description
   * Apply a format for the image source of the layer
   * @param {FormatQualifier} format A to apply to the layered image, see more {@link Qualifiers.Format|here}
   * @returns {this}
   */
  format(format) {
    this._qualifierModel.format = format.toString();
    this._format = format;
    return this;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { url, transformation, format } = qualifierModel;
    const result = new this(url);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    if (format) {
      result.format(new FormatQualifier(format));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/internal/models/createTextStyleFromModel.js
function createTextStyleFromModel(textStyleModel) {
  const { fontFamily, fontSize, fontWeight, fontStyle, fontAntialias, fontHinting, textDecoration, textAlignment, stroke, letterSpacing, lineSpacing } = textStyleModel;
  const result = new TextStyle(fontFamily, fontSize);
  if (fontWeight) {
    result.fontWeight(fontWeight);
  }
  if (fontStyle) {
    result.fontStyle(fontStyle);
  }
  if (fontAntialias) {
    result.fontAntialias(fontAntialias);
  }
  if (fontHinting) {
    result.fontHinting(fontHinting);
  }
  if (textDecoration) {
    result.textDecoration(textDecoration);
  }
  if (textAlignment) {
    result.textAlignment(textAlignment);
  }
  if (stroke) {
    result.stroke();
    if (typeof stroke !== "boolean") {
      result.stroke(solid(stroke.width, stroke.color));
    }
  }
  if (letterSpacing) {
    result.letterSpacing(letterSpacing);
  }
  if (lineSpacing) {
    result.lineSpacing(lineSpacing);
  }
  return result;
}

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/TextSource.js
var TextSource = class extends BaseTextSource {
  constructor(fileName, textStyle) {
    super(fileName, textStyle);
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { text: text2, textStyle, textColor, backgroundColor, transformation } = qualifierModel;
    const result = new this(text2, textStyle ? createTextStyleFromModel(textStyle) : void 0);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    if (textColor) {
      result.textColor(textColor);
    }
    if (backgroundColor) {
      result.backgroundColor(backgroundColor);
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source/sourceTypes/AudioSource.js
var AudioSource = class extends BaseSource {
  constructor(publicId) {
    super();
    this._qualifierModel = {
      sourceType: "audio",
      publicId
    };
  }
  /**
   * @description
   * Returns the opening string of the layer,
   * This method is used internally within {@link SDK.LayerAction|LayerAction}
   * @returns {string}
   */
  getOpenSourceString(layerType) {
    const encodedPublicID = this.encodeAssetPublicID(this._qualifierModel.publicId);
    return `${layerType}_audio:${encodedPublicID}`;
  }
  static fromJson(qualifierModel, transformationFromJson) {
    const { publicId, transformation } = qualifierModel;
    const result = new this(publicId);
    if (transformation) {
      result.transformation(transformationFromJson(transformation));
    }
    return result;
  }
};

// node_modules/@cloudinary/transformation-builder-sdk/qualifiers/source.js
function image(publicID) {
  return new ImageSource(publicID);
}
function text(text2, textStyle) {
  return new TextSource(text2, textStyle);
}
function video(publicID) {
  return new VideoSource(publicID);
}
function audio(publicID) {
  return new AudioSource(publicID);
}
function subtitles(fileName) {
  return new SubtitlesSource(fileName);
}
function fetch(remoteURL) {
  return new FetchSource(remoteURL);
}
var Source = { image, text, video, subtitles, fetch, audio };

export {
  createUnsupportedError,
  VideoSource,
  ImageSource,
  FontWeight,
  FontStyle,
  TextDecoration,
  Stroke,
  QualifierValue,
  Qualifier,
  FlagQualifier,
  Action,
  prepareColor,
  FormatQualifier,
  base64Encode,
  FetchSource,
  TextSource,
  AudioSource,
  image,
  text,
  video,
  audio,
  subtitles,
  fetch,
  Source
};
//# sourceMappingURL=chunk-PA5H62BW.js.map
